[{"title":"冒泡排序","url":"/2020/07/19/冒泡排序/","content":"title: 冒泡排序\n## 冒泡排序\n==1.下面我们来说以下冒泡排序的原理==\n（1）比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。 \n（2）对每一对相邻元素做同样的工作，从开始第一对元素到结尾的后一对元素。终后位置的元素就是大值。\n例如：\n排序前：{4,5,6,3,2,1}\n\n  排序后：{1,2,3,4,5,6}\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200705213621781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODAzMjg1,size_16,color_FFFFFF,t_70#pic_center)\n ==2.下面关冒泡排序的代码==\n \n**第一版冒泡排序**\n```java\npublic class Bubble \n{\n\t//两两比较交换位置\n\tpublic static void sort(int [] arr)\n\t{\n\t\t//外层比较的次数\n\t\tfor(int i=arr.length-1;i>0;i--)\n\t\t{\n\t\t\t//内层比较到的位置\n\t\t\tfor(int j=0;j<i;j++)\n\t\t\t{\n\t\t\t\tif(arr[j]>arr[j+1])\n\t\t\t\t{\n\t\t\t\t\tint temp=arr[j];\n\t\t\t\t\tarr[j]=arr[j+1];\n\t\t\t\t\tarr[j+1]=temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n从第一版冒泡排序中我们可以看出有弊端，在第五次进行完毕后，数组已经有序，可是还是进行了一轮排序，我们可以对他进行改进。\n\n**第二版冒泡排序**\n\n```java\npublic class Bubble \n{\n\t//两两比较交换位置\n\tpublic static void sort(int [] arr)\n\t{\n\t\t//外层比较的次数\n\t\tfor(int i=arr.length-1;i>0;i--)\n\t\t{   \n\t\t    boolean isSorted=true;   //有序标记\n\t\t\t//内层比较到的位置\n\t\t\tfor(int j=0;j<i;j++)\n\t\t\t{\n\t\t\t\tif(arr[j]>arr[j+1])\n\t\t\t\t{\n\t\t\t\t\tint temp=arr[j];\n\t\t\t\t\tarr[j]=arr[j+1];\n\t\t\t\t\tarr[j+1]=temp;\n\t\t\t\t\t//因为有元素的交换，所以不是有序的，改变标记\n\t\t\t\t\tisSorted=false;  \n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isSorted)\n\t\t{\n\t\t   break;\n\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n}\n```\n\n从第二版中我们虽然有了优化，不过性能还没有改变，我们还可以接着优化\n\n**第三版冒泡排序**\n\n```java\npublic class Bubble \n{\n\t//两两比较交换位置\n\tpublic static void sort(int [] arr)\n\t{\n\t    int lastExchangeIndex=0; //记录最后一次交换的位置\n\t    int sosortBorder=arr.length-1; //无序序列的边界位置\n\t\t//外层比较的次数\n\t\tfor(int i=arr.length-1;i>0;i--)\n\t\t{   \n\t\t    boolean isSorted=true;   //有序标记\n\t\t\t//内层比较到的位置\n\t\t\tfor(int j=0;j<sortBorder;j++)\n\t\t\t{\n\t\t\t\tif(arr[j]>arr[j+1])\n\t\t\t\t{\n\t\t\t\t\tint temp=arr[j];\n\t\t\t\t\tarr[j]=arr[j+1];\n\t\t\t\t\tarr[j+1]=temp;\n\t\t\t\t\t//因为有元素的交换，所以不是有序的，改变标记\n\t\t\t\t\tisSorted=false; \n\t\t\t\t\tlastExchangeIndex=j;  //更新最后一次标记位置\n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t}\n\t\t\tsosortBorder=lastExchangeIndex;\n\t\t\tif(isSorted)\n\t\t{\n\t\t   break;\n\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n}\n```\n以上三版已经优化的差不多了，不过还有一些特殊的情况，所以我们来看一下第四版代码。\n\n**第四版冒泡排序**\n\n```java\npublic class Bubble \n{\n\t//两两比较交换位置\n\tpublic static void sort(int [] arr)\n\t{\n\t\tfor(int i=0;i<arr.length/2;i++)\n\t\t{   \n\t\t    boolean isSorted=true;   //有序标记\n\t\t\t//内层比较到的位置\n\t\t\t//奇数轮，从左到右比较\n\t\t\tfor(int j=i;j<arr.length-i-1;j++)\n\t\t\t{\n\t\t\t\tif(arr[j]>arr[j+1])\n\t\t\t\t{\n\t\t\t\t\tint temp=arr[j];\n\t\t\t\t\tarr[j]=arr[j+1];\n\t\t\t\t\tarr[j+1]=temp;\n\t\t\t\t\t//因为有元素的交换，所以不是有序的，改变标记\n\t\t\t\t\tisSorted=false; \t \n\t\t\t\t}\n\t\t\t}\n\t\t\t//偶数轮之前，改标记,从右向左比较\n\t\t\tisSorted=true; \n\t\t\tfor(int j=arr.length-i-1;j>i;j--)\n\t\t\t{\n\t\t\t\tif(arr[j]<arr[j-1])\n\t\t\t\t{\n\t\t\t\t\tint temp=arr[j];\n\t\t\t\t\tarr[j]=arr[j-1];\n\t\t\t\t\tarr[j-1]=temp;\n\t\t\t\t\t//因为有元素的交换，所以不是有序的，改变标记\n\t\t\t\t\tisSorted=false; \t \n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isSorted)\n\t\t{\n\t\t   break;\n\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n}\n```\n==好了，冒泡排序已经完成，大家有什么不懂的可以留言或者评论问我。==\n==有什么不对的也欢迎大家指出，共同进步！！！==\n\n\n\n"},{"title":"欢迎大家来访","url":"/2020/07/17/hello-world/","content":"Welcome to ！！！\n"}]