[{"title":"复制多级文件夹里的文件的和删除文件的软件","url":"/2020/07/28/复制多级文件夹里的文件的和删除文件的软件/","content":"## 复制多级文件夹里的文件的和删除文件的软件\n<!-- more -->\n主要我有点懒，然后文件分布在不同的文件夹，需要复制然后删除有点麻烦所以制作了这个小软件，界面什么的还不好看，后面有时间会优化的源代码和软件我放在了GitHub的仓库有需要的大家可以去下载。\n[软件地址](https://github.com/Daylight629/CopyFile)\n软件大概是这样子的，还有点丑大家不要介意啊，后悔有时间再优化![在这里插入图片描述](https://img-blog.csdnimg.cn/20200728164320105.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODAzMjg1,size_16,color_FFFFFF,t_30)![软件界面](https://img-blog.csdnimg.cn/20200728164514217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODAzMjg1,size_16,color_FFFFFF,t_70)\n==下面来说一下核心代码==\n\n```java\n    //遍历获取文件\n    public static void copyFile(File srcFile, String s, String lu, boolean isdelete) {\n\n        //获取文件和文件夹数组\n        File[] ff = srcFile.listFiles();\n\n        for (File f : ff) {\n            //判断是否为文件夹\n            if (f.isDirectory()) {\n                copyFile(f, s,lu,isdelete);\n            } else {\n                if (f.getName().endsWith(s))\n                    copyFile(f,lu);\n                if (isdelete)\n                    deleteFile(f);\n\n            }\n        }\n    }\n```\n\n```java\n  //复制文件\n    private static void copyFile(File srcFile,String lu) {\n\n        BufferedInputStream bi = null;\n        BufferedOutputStream bo = null;\n        try {\n\n            File destFile = new File(lu, srcFile.getName());\n            bi = new BufferedInputStream(new FileInputStream(srcFile));\n            bo = new BufferedOutputStream(new FileOutputStream(destFile));\n\n            byte[] bys = new byte[1024 * 100];\n            int len = 0;\n            while ((len = bi.read(bys)) != -1) {\n                bo.write(bys, 0, len);\n            }\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                bo.close();\n                bi.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n```\n\n```java\n    //删除文件\n    private  static void deleteFile(File srcFile)\n    {\n        srcFile.deleteOnExit();\n        srcFile.delete();\n    }\n```\n关于图形用户界面的代码比较多，有需要的可以到上面提供的链接下载哦\n今天就分享好这里，感谢大家观看，使用软件中发现什么bug可以给我留言哦！\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200728165126721.gif)\n"},{"title":"JDK的安装与环境变量配置与Editplus配置","url":"/2020/07/19/JDK的安装与环境变量配置与Editplus配置/","content":"## JDK的安装与环境变量配置与Editplus配置\n<!-- more -->\n1.下面我们来先说一下jdk的下载\n大家可以到甲骨文公司下载需要的版本\n                   [oracle官网](https://www.oracle.com)\n 安装的时候初学者建议自己修改安装路径，方便配置环境变量\n 2.下面关于环境变量的配置\n （1）打开此电脑的属性\n    （2）打开高级系统设置\n    （3）打开环境变量\n    （4）在系统变量中新建\n    （5）名字为JAVA_HOME路径找到你安装jdk的路径复制进去就行\n    （6）打开path的编辑 添加%JAVA_HOME%\\bin 然后记得点确定\n    （7）win+r输入cmd回车 输入javac命令 如果出现了版本号等等一系列的东西说明环境变量配置成功了\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200519170908447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODAzMjg1,size_16,color_FFFFFF,t_70#pic_center)\n   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200519171044132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODAzMjg1,size_16,color_FFFFFF,t_70#pic_center)\n 3.Editplus配置\n 我们在使用中dos命令窗口太麻烦，所以一般使用其他的记事本工具，不过建议初学者先使用这个不要用太高级的IDE\n （1）安装好后\n （2）打开工具然后选择配置用户工具\n （3）先添加工具选择应用程序\n （4）先配置compile也就是javac命令，菜单文本你可以写我这个也可以自己定义\n （5）命令找到jdk安装目录然后打开bin文件夹找到javac添加进去\n （5）参数选择$(FileName)\n \n （6）初始目录选择$(FileDir)\n （7）记得点应用然后点确定\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200519174558726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODAzMjg1,size_16,color_FFFFFF,t_70#pic_center)\n （8）配置run命令也就是java命令，菜单文本你可以写我这个也可以自己定义。\n （9）命令找到jdk安装目录然后打开bin文件夹找到java添加进去\n （10）参数选择(FileNameNoExt)\n （11）初始目录为(FileDir)\n （12）记得点应用然后点确定\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200519175047858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODAzMjg1,size_16,color_FFFFFF,t_70#pic_center)\n"},{"title":"冒泡排序","url":"/2020/07/19/冒泡排序/","content":"## 冒泡排序\n<!-- more -->\n1.下面我们来说以下冒泡排序的原理\n（1）比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。 \n（2）对每一对相邻元素做同样的工作，从开始第一对元素到结尾的后一对元素。终后位置的元素就是大值。\n例如：\n排序前：{4,5,6,3,2,1}\n\n  排序后：{1,2,3,4,5,6}\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200705213621781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODAzMjg1,size_16,color_FFFFFF,t_70#pic_center)\n ==2.下面关冒泡排序的代码==\n \n**第一版冒泡排序**\n```java\npublic class Bubble \n{\n\t//两两比较交换位置\n\tpublic static void sort(int [] arr)\n\t{\n\t\t//外层比较的次数\n\t\tfor(int i=arr.length-1;i>0;i--)\n\t\t{\n\t\t\t//内层比较到的位置\n\t\t\tfor(int j=0;j<i;j++)\n\t\t\t{\n\t\t\t\tif(arr[j]>arr[j+1])\n\t\t\t\t{\n\t\t\t\t\tint temp=arr[j];\n\t\t\t\t\tarr[j]=arr[j+1];\n\t\t\t\t\tarr[j+1]=temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n从第一版冒泡排序中我们可以看出有弊端，在第五次进行完毕后，数组已经有序，可是还是进行了一轮排序，我们可以对他进行改进。\n\n**第二版冒泡排序**\n\n```java\npublic class Bubble \n{\n\t//两两比较交换位置\n\tpublic static void sort(int [] arr)\n\t{\n\t\t//外层比较的次数\n\t\tfor(int i=arr.length-1;i>0;i--)\n\t\t{   \n\t\t    boolean isSorted=true;   //有序标记\n\t\t\t//内层比较到的位置\n\t\t\tfor(int j=0;j<i;j++)\n\t\t\t{\n\t\t\t\tif(arr[j]>arr[j+1])\n\t\t\t\t{\n\t\t\t\t\tint temp=arr[j];\n\t\t\t\t\tarr[j]=arr[j+1];\n\t\t\t\t\tarr[j+1]=temp;\n\t\t\t\t\t//因为有元素的交换，所以不是有序的，改变标记\n\t\t\t\t\tisSorted=false;  \n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isSorted)\n\t\t{\n\t\t   break;\n\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n}\n```\n\n从第二版中我们虽然有了优化，不过性能还没有改变，我们还可以接着优化\n\n**第三版冒泡排序**\n\n```java\npublic class Bubble \n{\n\t//两两比较交换位置\n\tpublic static void sort(int [] arr)\n\t{\n\t    int lastExchangeIndex=0; //记录最后一次交换的位置\n\t    int sosortBorder=arr.length-1; //无序序列的边界位置\n\t\t//外层比较的次数\n\t\tfor(int i=arr.length-1;i>0;i--)\n\t\t{   \n\t\t    boolean isSorted=true;   //有序标记\n\t\t\t//内层比较到的位置\n\t\t\tfor(int j=0;j<sortBorder;j++)\n\t\t\t{\n\t\t\t\tif(arr[j]>arr[j+1])\n\t\t\t\t{\n\t\t\t\t\tint temp=arr[j];\n\t\t\t\t\tarr[j]=arr[j+1];\n\t\t\t\t\tarr[j+1]=temp;\n\t\t\t\t\t//因为有元素的交换，所以不是有序的，改变标记\n\t\t\t\t\tisSorted=false; \n\t\t\t\t\tlastExchangeIndex=j;  //更新最后一次标记位置\n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t}\n\t\t\tsosortBorder=lastExchangeIndex;\n\t\t\tif(isSorted)\n\t\t{\n\t\t   break;\n\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n}\n```\n以上三版已经优化的差不多了，不过还有一些特殊的情况，所以我们来看一下第四版代码。\n\n**第四版冒泡排序**\n\n```java\npublic class Bubble \n{\n\t//两两比较交换位置\n\tpublic static void sort(int [] arr)\n\t{\n\t\tfor(int i=0;i<arr.length/2;i++)\n\t\t{   \n\t\t    boolean isSorted=true;   //有序标记\n\t\t\t//内层比较到的位置\n\t\t\t//奇数轮，从左到右比较\n\t\t\tfor(int j=i;j<arr.length-i-1;j++)\n\t\t\t{\n\t\t\t\tif(arr[j]>arr[j+1])\n\t\t\t\t{\n\t\t\t\t\tint temp=arr[j];\n\t\t\t\t\tarr[j]=arr[j+1];\n\t\t\t\t\tarr[j+1]=temp;\n\t\t\t\t\t//因为有元素的交换，所以不是有序的，改变标记\n\t\t\t\t\tisSorted=false; \t \n\t\t\t\t}\n\t\t\t}\n\t\t\t//偶数轮之前，改标记,从右向左比较\n\t\t\tisSorted=true; \n\t\t\tfor(int j=arr.length-i-1;j>i;j--)\n\t\t\t{\n\t\t\t\tif(arr[j]<arr[j-1])\n\t\t\t\t{\n\t\t\t\t\tint temp=arr[j];\n\t\t\t\t\tarr[j]=arr[j-1];\n\t\t\t\t\tarr[j-1]=temp;\n\t\t\t\t\t//因为有元素的交换，所以不是有序的，改变标记\n\t\t\t\t\tisSorted=false; \t \n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isSorted)\n\t\t{\n\t\t   break;\n\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n}\n```\n好了，冒泡排序已经完成，大家有什么不懂的可以留言或者评论问我。\n有什么不对的也欢迎大家指出，共同进步！！！\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200705220815600.gif#pic_center)\n\n\n"},{"title":"欢迎大家来访","url":"/2020/07/17/hello-world/","content":"Welcome to ！！！\n"}]